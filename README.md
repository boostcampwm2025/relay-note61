# relay-note61

# 부스트캠프 AI 활용 릴레이 노트 🏃🏻✍️
<br/>

## 우리가 했던 고민은..? 🤔
### 1. 방대한 학습과 구현에 지친 몸과 마음
- 하루종일 컴퓨터 앞에서 지내다 나를 돌볼 시간이 부족함. 
- 나를 돌아보고 동기부여할 시간이 필요함.
### 2. 왜 그렇게 만들었는가?
- 개발자로 성장하는 과정에서 어떻게 만들었는가 보다 중요한 것은 왜 그렇게 만들었는가에 대한 설명 능력.
- ai를 활용해 이 능력을 향상 시키고 싶음

### 3. 체크포인트가 적절하지 않아 미션 수행에서 다른 방향으로 갈 때가 있음
- 체크포인트의 순서와 학습 목표가 맞지 않으면 엉뚱한 작업을 하게 되어 야크털을 깎게 됨
- AI를 통해 체크 포인트를 점검학여 이 과정을 줄일 수 있을 거 같음

### 4. 학습 & 구현 비율 조절의 어려움
- 어떤 개념을 깊이 학습해야 하는지 또는 이미 알고 있는 부분인지 판단하기 어려움
- 구현에만 집중하여 중요한 개념을 놓치거나 방대한 양을 모두 학습하려는 상황 발생

<br/><br/>


## AI 활용 퀘스트 제안 👍

### 1. AI를 활용한 하루 감사일기와 회고 😇

### 2. 설계를 한 뒤 "왜 그렇게 만들었는가?"에 대한 내용이 담겨있는지 검사해주는 gpt

### 3. AI를 통해 나만의 체크포인트 점검하기

### 4. AI가 생성해주는 퀴즈를 통해 배경 지식 점검
<br/><br/>


## 커뮤니티 또는 학습과 성장의 방향성 🌳💫

### 1. 지치지 않고 끝까지 완주할 수 있도록 서로 독려하는 커뮤니티 🙌🏻<br/>
### 2. 성장과 지속가능성을 함께하는 커뮤니티 💪🏻<br/>
### 3. AI에 의존하기보다 적절히 활용해 균형을 지키는 커뮤니티 💻<br/>
<br/><br/>

# 선택 이유

`재미와 도파민을 위해 핀볼로 결정`

<img width="676" height="1310" alt="image" src="https://github.com/user-attachments/assets/aa01fbe0-dc22-4099-9add-507f343f3aa6" />


밑에서부터 1번 2번 3번 4번순으로 결정

## 결과

- AI를 활용한 하루 감사일기와 회고 : J115 박은지
- 설계 검토 gpt : J251 조성민
- AI를 통해 나만의 체크포인트 점검하기: S025 이선호
- AI 기반 미션 학습목표 기준 배경지식 점검 퀴즈 생성 및 풀이: J069 김준성
-----------
# AI를 통해 나만의 체크포인트 점검하기 
마블 미션을 예시로 정했습니다.
``` swift
## 구조 설계
- [ ] 타노스 & 캐릭터 클래스 분리
- [ ] 보드 클래스 분리
- [ ] 출력 관리 클래스 분리

### 보드 클래스
- [ ] display() -> []: A행부터 E행까지 전체 행 단위를 의미 있는 데이터 구조로 리턴 & 이후에 출력 담당하는 객체에서 문자열로 바꾸고 출력
- [ ] createHero(HeroType, 위치) throws: 들어온 히어로 타입에 따라 매개변수에 있는 위치에 생성이 가능한지 체크
  - 초기 위치 확인 & 해당 위치에 다른 말 있는지 확인 & 종류별 개수 확인
- [ ] forceCreateHero(HeroType, 위치) throws: 최대 개수 고려하지 않고 오직 해당 위치가 비어있으면 캐릭터 무조건 생성
- [ ] attack(from,to) -> Int: from->to공격하고 to의 HP 반환. 0이되거나 소멸되면 0반환 or 해당 자리에 아무것도 없으면 이동

### 공통 캐릭터 클래스
- [ ] 위치: Postion 타입
- [ ] 스톤: 타노스 제외 전부 White, Blue, Red, Green, Orange< Violet중 하나를 가짐. 
- [ ] 강탈: HP가 초기값 보다 절반 이하가 되면 뺏김. 
- [ ] 체력: 본인 체력 저장하자
### 타노스 클래스(스톤을 인스턴스끼리공유해야함)
- [ ] move(Postion): 타노스는 어디든 두칸 연속해 비어있으면 이동 가능
- [ ] attack(): 공격으로 상대 stone뺏을때마다 HP + 50, 공격력 + 10
### BW 클래스
- [ ] move() : 상화좌우 1칸씩만 다른말이 없을때 이동
- [ ] 스톤: Orange
### LK 클래스
- [ ] move(): 대각선만 이동가능. 그런데 가는길에 막혀있으면 못감.
- [ ] 스톤: Blue
### HULK 클래스
- [ ] move() : 위 아래만 안막혀 있을때 이동 가능
- [ ] 스톤: White
### SM 클래스
- [ ] Move(): 막혀있든 말든 아무곳이나 간다
- [ ] 스톤: RED
### TH 클래스
- [ ] Move() : 좌,우,상,하 인데 1이 아니라 끝까지도 가능 But) 안막혀있을때만 
- [ ] 스톤: Violet
### DS 클래스
- [ ] Move(): 상하좌우 길중간이 막혀도 이동 가능
- [ ] 스톤: Green

### 입출력 클래스
- [ ] ?입력시 상대 캐릭터들의 HP print
- [ ] 이동시 나와야 하는 print 구현
```
프롬프트 스크립트:  이러한 문제를 풀이하기 위해 먼저 접근법을 확인하려해. 어떤 순서로 접근을 하면되는지 내가 미리 체크리스트를 작성했는데 내 체크리스트를 확인하고 너가 만약 틀린 순서나 더 좋은 순서가 있다면 수정해줘 
### 수정후
```
좋은 접근법이네요! 전체적으로 객체지향 설계 원칙을 잘 반영하고 있습니다. 몇 가지 개선사항과 추가 고려사항을 제안드리겠습니다.
수정된 체크리스트
1. 기본 데이터 구조부터 시작 (가장 작은 단위)

 Position 클래스: 위치를 표현하는 기본 데이터 타입
 Stone 열거형/클래스: 6가지 스톤 타입 정의
 Team 열거형: 플레이어/컴퓨터 구분

2. 캐릭터 계층 구조 설계

 Character 추상 클래스: 모든 캐릭터의 공통 기능

HP, 공격력, 위치, 팀, 스톤 관리
추상 메서드: canMoveTo(), getMovementPattern()


 개별 캐릭터 클래스들: Thanos, BlackWidow, Hulk, etc.

3. 게임 로직 핵심 클래스들

 Board 클래스:

display() → 의미있는 데이터 구조 반환
createHero(), forceCreateHero(), attack() 메서드


 GameRule 클래스: 초기 배치 규칙, 이동 규칙 검증
 StoneManager 클래스: 스톤 공유 및 강탈 로직 관리

4. 입출력 및 제어 계층

 InputValidator 클래스: 입력 형식 검증 (A1->B2 패턴)
 OutputFormatter 클래스: Board 데이터를 문자열로 변환
 GameController 클래스: 전체 게임 흐름 제어
 ComputerPlayer 클래스: AI 로직
```
이런 식으로 기존거보다 좀더 추상화해서 체크포인트를 적어주었습니다. 오히려 클래스 네이밍까지도 추천을 해주네요 아직저기까지 생각안했는데 너무 큰 힌트를 줘버리는 느낌..성장을 막아버리는 느낌을 받습니다.

# AI 기반 미션 학습목표 기준 배경지식 점검 퀴즈 생성 및 풀이

## 요구사항 정리

### 질문

```
내가 컴퓨터 공학에 대한 학습을 진행하기 전에, 특정 주제에 대한 배경지식을 점검해보려해.
학습목표를 제공해주면, 그 학습 목표를 바탕으로 퀴즈를 만들어줄 수 있어?
퀴즈는 객관식 4개, 주관식 1개로 만들어 줬으면 좋겠어.
```

퀴즈를 만들기 전에, LLM에게 만들어야 할 문제의 큰 범주(컴퓨터 공학)을 설명했습니다.

그리고 문제를 어떤 형식으로 제공할지 가이드를 해줬습니다.

### 답변

```
물론이지! 아래와 같은 형식으로 진행할 수 있어:

⸻

✅ 예시 입력:
학습 목표: “운영체제에서 프로세스와 스레드의 차이를 이해한다.”

📘 결과 예시:

퀴즈 주제: 프로세스와 스레드의 개념과 차이점

1. 객관식 (4지선다)
Q1. 다음 중 프로세스에 대한 설명으로 옳지 않은 것은?
A. 프로세스는 운영체제에서 자원을 할당받는 기본 단위이다.
B. 각 프로세스는 자신만의 독립된 주소 공간을 가진다.
C. 프로세스 간의 문맥 전환은 매우 빠르다.
D. 하나의 프로세스는 여러 개의 스레드를 포함할 수 있다.

정답: C

Q2. 스레드에 대한 설명으로 알맞은 것은?
A. 스레드는 서로 다른 메모리 공간에서 실행된다.
B. 스레드는 커널 수준에서만 관리된다.
C. 하나의 프로세스 내에서 여러 스레드는 메모리 공간을 공유한다.
D. 스레드는 독립적인 PID를 갖는다.

정답: C

Q3. 다음 중 스레드의 장점으로 부적절한 것은?
A. 자원 공유를 통해 효율적인 통신이 가능하다.
B. 문맥 전환 비용이 적다.
C. 안정성이 높아 다른 스레드의 오류에 영향을 받지 않는다.
D. 병렬 처리를 통한 응답성 향상이 가능하다.

정답: C

Q4. 프로세스와 스레드의 차이에 대한 설명 중 가장 적절한 것은?
A. 스레드는 운영체제에서 자원을 할당받는 기본 단위이다.
B. 프로세스 간 통신은 스레드 간 통신보다 간단하다.
C. 스레드는 독립적으로 실행되며, 각자의 코드 영역을 갖는다.
D. 프로세스는 독립적이며, 스레드는 같은 프로세스의 자원을 공유한다.

정답: D

2. 주관식
Q5. 프로세스와 스레드의 가장 큰 차이점은 무엇인가요? 간단히 서술하세요.

예시 답변: 프로세스는 독립적인 메모리 공간과 자원을 가지지만, 스레드는 같은 프로세스의 메모리 공간과 자원을 공유한다.

⸻

학습 목표만 알려주면, 위와 같은 포맷으로 바로 만들어줄게!
준비됐으면 학습 목표를 알려줘 :)
```

답변을 위와 같이 답변해줬습니다.

문제와 답을 제시하는것은 필요가 없을 것 같습니다.

## 학습목표 제공하기

### 질문

```
**학습목표**
- 프로세스와 스레드의 차이점을 이해하고, 스레드로 병렬 처리를 할 수 있도록 구현한다.
- 멀티 스레드 환경에서 공동 리소스에 접근하는 경우 레이스 컨디션이 발행하는 원리와 대응 방법을 구현한다.

답은 공개하지 말아줘.
```

답을 제공받지 않기 위해 '답을 공개하지 말아줘.'라고 요청했습니다.

### 답변

```
좋아! 아래는 네가 제시한 학습 목표를 바탕으로 만든 퀴즈야.
답은 포함하지 않았고, 학습 전에 자신을 점검하거나 스터디 때 활용하기 좋아.

⸻

🧠 주제: 프로세스 vs 스레드, 병렬 처리와 레이스 컨디션

1. 객관식 문제

Q1. 다음 중 스레드에 대한 설명으로 가장 적절한 것은?
A. 각 스레드는 독립된 주소 공간을 가진다.
B. 스레드는 운영체제의 스케줄러에 의해 관리되지 않는다.
C. 동일한 프로세스 내 스레드는 메모리 자원을 공유한다.
D. 스레드는 항상 별도의 커널 공간을 가진다.

⸻

Q2. 다음 중 병렬 처리를 위한 멀티 스레드 프로그래밍의 이점으로 적절하지 않은 것은?
A. I/O 대기 시간 단축
B. 계산 병렬화
C. 전역 변수로 인한 안정성 보장
D. 응답성 향상

⸻

Q3. 다음 중 레이스 컨디션이 발생할 수 있는 시나리오로 가장 알맞은 것은?
A. 두 스레드가 서로 다른 파일에 데이터를 쓰는 경우
B. 하나의 스레드가 데이터를 읽고 다른 스레드가 같은 데이터를 동시에 수정하는 경우
C. 싱글 스레드 환경에서 반복문을 실행하는 경우
D. 각 스레드가 독립적인 지역 변수만을 사용하는 경우

⸻

Q4. 레이스 컨디션을 방지하기 위한 방법으로 적절한 것을 고르시오.
A. 전역 변수 사용을 최소화한다
B. 스레드 간 통신을 금지한다
C. 임계 영역에 락(lock)을 사용한다
D. 스레드 수를 줄인다

⸻

2. 주관식 문제

Q5. 멀티 스레드 환경에서 레이스 컨디션이 발생하는 원인을 설명하고, 이를 방지하기 위한 대표적인 방법을 하나 서술하세요.

⸻

필요하다면 이 문제들을 Markdown, PDF, Quiz App 포맷 등으로도 변환해줄 수 있어.
또는 정답 검토도 원하면 말해줘!
```

퀴즈를 제공받아서 풀어보겠습니다.

## 퀴즈풀이

### 답변

```
답변을 적어왔어.

1. C
2. C
3. B
4. C
5. 스레드는 프로세스의 힙영역을 공유한다. 공유한 힙영역의 값 조작하고 있는 스레드 A가 잠깐 대기 상태일때, 스레드 B가 조작해서 A의 결과값이 예상과 다르게 나올 수 있다. 이를 막기 위해서 뮤텍스, 세마모어 등의 락을 이용하여 값을 atomic하게 관리한다.
```

### 해설

```
좋아! 하나씩 검토해볼게.
전반적으로 아주 잘 이해하고 있어. 다만 몇 가지는 더 명확하게 다듬으면 더 좋을 것 같아.

⸻

✅ 1. C – 정답

“동일한 프로세스 내 스레드는 메모리 자원을 공유한다.”
정확해! 특히 힙(heap), 전역 변수, 열린 파일 디스크립터 등을 공유한다는 점이 핵심이야.

⸻

✅ 2. C – 정답

“전역 변수로 인한 안정성 보장”
이건 오히려 위험 요소에 해당하지. 전역 변수는 스레드 간에 공유되어 예측 불가능한 문제가 생기기 쉬워. 이 선택지를 잘 골랐어!

⸻

✅ 3. B – 정답

“하나의 스레드가 데이터를 읽고, 다른 스레드가 같은 데이터를 동시에 수정하는 경우”
레이스 컨디션의 고전적인 예시야. 타이밍에 따라 결과가 달라져서 디버깅도 어렵지.

⸻

✅ 4. C – 정답

“임계 영역에 락(lock)을 사용한다.”
mutex, spinlock, semaphore 등 다양한 락이 레이스 컨디션 해결에 사용돼. 정확하게 짚었어.

⸻

✅ 5. 주관식 평가

답변:

스레드는 프로세스의 힙 영역을 공유한다. 공유한 힙영역의 값을 조작하고 있는 스레드 A가 잠깐 대기 상태일 때, 스레드 B가 조작해서 A의 결과값이 예상과 다르게 나올 수 있다. 이를 막기 위해서 뮤텍스, 세마포어 등의 락을 이용하여 값을 atomic하게 관리한다.

🟢 좋은 점:
	•	원인 설명이 명확해. 공유된 자원에 대한 경쟁이 문제라는 걸 잘 짚었고, 예시도 이해를 돕는 데 효과적이야.
	•	해결 방법도 정확해. mutex나 semaphore로 atomic하게 만든다는 표현도 실전 감각 있어.

🔵 보완하면 좋은 점:
	•	atomic하게 관리라는 표현은 좋지만, atomic 연산과 락을 이용한 보호는 별개로 구분될 수도 있어.
따라서 “락을 사용하여 임계 영역을 보호한다”라는 식으로 정리하면 더 명확해.

📘 예시로 다듬으면 이렇게 쓸 수 있어:

스레드는 같은 프로세스의 힙 영역을 공유하기 때문에, 한 스레드가 값을 조작하는 도중 다른 스레드가 같은 값에 접근하면 예기치 않은 결과가 발생할 수 있다. 이를 레이스 컨디션이라 하며, mutex나 semaphore를 이용해 임계 영역을 보호하여 해결할 수 있다.

⸻

🔚 총평
	•	전부 정답이고, 주관식도 매우 우수한 서술이야.
	•	개념 이해도도 좋고, 답변 방식도 실전용으로 충분히 적합해.

필요하면 이 주제에 대한 코드 예시나, 락의 종류 비교도 정리해줄 수 있어.
다음 주제로 넘어가도 좋고, 더 깊이 파고들고 싶으면 알려줘! 🚀
```

위와 같이 해설을 제공해줬습니다.

## 후기

개인적으로 문제가 너무 쉬워서, 난이도가 조금 높으면 좋을 것 같다는 생각이 들었습니다.

`atomic`이라는 키워드만을 제공해줬는데, `atomic 연산`과 `lock`이 엄연히 다르다고 말해줘서,

이 부분에 대해 복습하면 좋을 것 같다는 생각이 들었습니다.
